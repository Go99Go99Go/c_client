#include <stdio.h>
#include <iostream>
typedef char TElement; // 트리에 저장할 데이터의 자료형
typedef struct BinTrNode {
	TElement data; // 노드에 저장할 데이터
	struct BinTrNode* left; // 왼쪽 자식 노드의 포인터
	struct BinTrNode* right; // 오른쪽 자식 노드의 포인터
} TNode;

TNode* root = NULL;

void init_tree() { root = NULL; } //이진트리 초기화
int is_empty_tree() { return root == NULL; } //이진트리가 공백상태인지 확인
TNode* get_root() { return root; }

TNode* create_tree(TElement val, TNode* l, TNode* r) //이진트리 left와 right를 받아 val를 루트로 하는 이진트리를 생성한다.
{
	TNode* n = (TNode*)malloc(sizeof(TNode));
	n->data = val;
	n->left = l;
	n->right = r;
	return n;
}

int count_node(TNode* n) //트리의 갯수
{
	if (n == NULL)return 0;
	return 1 + count_node(n->left) + count_node(n->right);
}

int count_leaf(TNode* n)//자식노들이 없는 노드들의 갯수
{
	if (n == NULL)return 0;
	if (n->left == NULL && n->right == NULL) return 1;
	else return  count_leaf(n->left) + count_leaf(n->right);
}

int calc_height(TNode* n)
{
	int hLeft, hRight;
	if (n == NULL)return 0;
	hLeft = calc_height(n->left);
	hRight = calc_height(n->right);
	return (hLeft > hRight) ? hLeft + 1 : hRight + 1;
}

void preorder(TNode* n)//전위순회
{
	if (n != NULL) {
		printf("[%c] ", n->data);
		preorder(n->left);
		preorder(n->right);
	}
}

void inorder(TNode* n)//중위순회
{
	if (n != NULL) {
		inorder(n->left);
		printf("[%c] ", n->data);
		inorder(n->right);
	}
}

void postorder(TNode* n)//후위순회
{
	if (n != NULL) {
		postorder(n->left);
		postorder(n->right);
		printf("[%c] ", n->data);
	}
}



int main()
{
	TNode *b, *c, *d, *e, *f;
	init_tree();
	d = create_tree('D', NULL, NULL);
	e = create_tree('E', NULL, NULL);
	b = create_tree('B', d, e);
	f = create_tree('F', NULL, NULL);
	c = create_tree('C', f, NULL);
	root = create_tree('A', b, c);

	printf("노드의 개수 = %d\n",count_node(root));
	printf("단말의 개수 = %d\n", count_leaf(root));
	printf("트리의 높이 = %d\n", calc_height(root));
}

